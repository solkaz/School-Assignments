%{

#include "function.hpp"
#include "lexical_analyzer.hpp"
#include "print.hpp"
#include "symbol_table.hpp"
#include "utils.hpp"

#include <iostream>
#include <stack>
#include <string>

// i am ashamed of myself
using namespace std;

int num_temps, num_labels;

stack<string> while_stack;
stack<string> if_stack;
LexicalAnalyzer lexer;
SymbolTable globals("__GLOBAL__");
std::vector<Function> function_list;

int yylex();
int yyerror(const char* msg) {
    cerr << "Error: " << msg << endl;
    return 1;
}

void MakeAssembly();

string NewTempVar() {
    return "__T" + to_string(num_temps++);
}

string CurrentTempVar() {
    return "__T" + to_string(num_temps - 1);
}

string NewLabel() {
    return "__L" + to_string(num_labels++);
}

string CurrentLabel() {
    return "__L" + to_string(num_labels - 1);
}

string GetJumpInstruction(string opcode) {
    if (opcode == "LT") {
        return "BGE";
    } else if (opcode == "LTE") {
        return "BGT";
    } else if (opcode == "GTE") {
        return "BLT";
    } else if (opcode == "GT") {
        return "BLE";
    } else if (opcode == "EQ") {
        return "BNE";
    } else if (opcode == "NEQ") {
        return "BEQ";
    }
}

%}

%union {
    bool bval;
    int ival;
    string * sval;
}

%token<ival> NUMBER
%token<sval> 
    STRING ADDOP MULOP RELOP ASSIGNOP
    FUNCTION RETURN VAR ID IF
    ELSE WHILE AND COMMA CURLL
    CURLR NOT OR PARENL PARENR SEMICOLON
    ;
    
%type<sval>
    expr factor fcall body term bterm bexpr bfactor
    bneg fplist
    ;
    
%left ADDOP
%left MULOP

%%

pgm:
    pgmpart pgm 
    | pgmpart
    ;
    
pgmpart:
    vardecl
	| function
	;
	 
vardecl:
    VAR varlist SEMICOLON
	;
	
varlist:
    ID COMMA varlist {
        function_list.back().AddSymbol(
            make_pair(string(*$1), string("int"))
        );
    }
    | ID {
        function_list.back().AddSymbol(
            make_pair(string(*$1), string("int"))
        );
    }
    ;

function:
    FUNCTION ID PARENL PARENR {
        // Add the function to the global table
        string func_id = *$2;
        globals.AddSymbol(
            make_pair(func_id, string("func"))
        );
        // Construct a new function object
        function_list.emplace_back(func_id);
    } body {
        function_list.back().AddStatement(string("RET"));
    }
    | FUNCTION ID PARENL fplist PARENR {
        // Add the function to the global table
        string func_id = *$2;
        globals.AddSymbol(
            make_pair(func_id, string("func"))
        );
        // Construct a new function object
        function_list.emplace_back(func_id);
        function_list.back().SetParams(*$4);
    } body {
        function_list.back().AddStatement(string("RET"));
    }
    ;

body:
    CURLL bodylist CURLR
    ;

fplist:	
    ID COMMA fplist {
        $$ = new string(*$1 + ' ' + *$3);
    }
	| ID {
	    $$ = $1;
	}
	;

bodylist:
    vardecl bodylist
    | stmt bodylist
    | /* (Epsilon, AKA Nothing) */
    ;

stmt: 
    assign SEMICOLON
    | fcall SEMICOLON
    | while
    | if
    | body
    ;

assign:
    ID ASSIGNOP expr {
        string ops = *$3 + ' ' + *$1;
        function_list.back().AddStatement(string("MOV"), ops);
    }
    ;

expr: 
    factor {
        $$ = $1;
    }
    | expr ADDOP factor {
        string opcode = ((*$2)[0] == '+' ? "ADD" : "SUB");
        string ops = *$1 + ' ' + *$3 + ' ' + NewTempVar();
        function_list.back().AddStatement(opcode, ops);
        function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );
        $$ = new string (CurrentTempVar());
    }
    ;

factor:
    term {
        $$ = $1;
    }
	| factor MULOP term {
	    string opcode = ((*$2)[0] == '*' ? "MUL" : "DIV");
	    string ops = *$1 + ' ' + *$3 + ' ' + NewTempVar();
	    function_list.back().AddStatement(opcode, ops);
	    function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );
        $$ = new string (CurrentTempVar());
	}
	;

term: 
    ID {
        $$ = $1;
    }
    | NUMBER {
        $$ = new string (to_string($1));
    }
    | PARENL expr PARENR {
        $$ = $2;
    }
    | ADDOP term {
        if ((*$1)[0] == '-') {
            string new_temp = NewTempVar();
            function_list.back().AddSymbol(
                make_pair(new_temp, string("int"))
	        );
            string ops = *$2 + ' ' + new_temp;
            
            function_list.back().AddStatement(string("NEG"), ops);
            $$ = new string (new_temp);
        } else {
            $$ = $2;
        }
    }
    | fcall {
        $$ = $1;
    }
    ;

bexpr: 
    bfactor { $$ = $1; }
    | bexpr OR bfactor {
        function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );

        string ops = *$1 + ' ' + *$3 + ' ' + NewTempVar();
        function_list.back().AddStatement(string("OR"), ops);
        $$ = new string(CurrentTempVar());
    }
    ;

bfactor: 
    bneg { $$ = $1; }
    | bfactor AND bneg {
        string ops = *$1 + ' ' + *$3 + ' ' + NewTempVar();
        function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );
        function_list.back().AddStatement("AND", ops);
        $$ = new string(CurrentTempVar());
    }
    ;

bneg:
    bterm { $$ = $1; }
	| NOT bterm {
	    string args = *$2 + ' ' + NewTempVar();
	    function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );
	    function_list.back().AddStatement("NOT", args);
	    $$ = new string(CurrentTempVar());
	}
	;

bterm: 
    expr RELOP expr {
        string args = *$1 + ' ' + *$3;
        function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );
        string instruction;
        if (*$2 == "<") {
            instruction = "LT";
        } else if (*$2 == ">") {
            instruction = "GT";
        } else if (*$2 == "==") {
            instruction = "EQ";
        } else if (*$2 == "!=") {
            instruction = "NEQ";
        } else if (*$2 == "<=") {
            instruction = "LTE";
        } else if (*$2 == ">=") {
            instruction = "GTE";
        }
        string jump_opcode = GetJumpInstruction(instruction);
        function_list.back().AddStatement("CMP", args);
        function_list.back().AddStatement(jump_opcode, NewLabel());
        $$ = new string(CurrentTempVar());
    }
    | PARENL bterm PARENR {
        $$ = $2;
    }
    ;

fcall: 
    ID PARENL PARENR {
        // Print the CALL instruction
        function_list.back().AddStatement("CALL", *$1);
        // Store the result in a new temp variable
        function_list.back().AddStatement("STRET", NewTempVar());
        function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );
	    $$ = new string (CurrentTempVar());
    }
    | ID PARENL aplist PARENR {
        function_list.back().AddStatement("CALL", *$1);
        // Store the result in a new temp variable
        function_list.back().AddStatement("STRET", NewTempVar());
        function_list.back().AddSymbol(
            make_pair(CurrentTempVar(), string("int"))
	    );
        $$ = new string (CurrentTempVar());
    }
    ;

aplist:
    expr COMMA aplist {
        function_list.back().AddStatement("PARAM", *$1);
    }
	| expr {
	    function_list.back().AddStatement("PARAM", *$1);
	}
	| STRING {
	    function_list.back().AddStatement("PARAM", *$1);
	}
	;

while:
    WHILE {
        function_list.back().AddLabel(NewLabel());
        while_stack.push(CurrentLabel());
    } PARENL bexpr PARENR {
        while_stack.push(CurrentLabel());
    } stmt {
        string outLayer = while_stack.top(); while_stack.pop();
        string topLayer = while_stack.top(); while_stack.pop();
        function_list.back().AddStatement("BA", topLayer);
        function_list.back().AddLabel(outLayer);
    }
	;

if: 
    IF {
        if_stack.push(CurrentLabel());
    } PARENL bexpr PARENR {
        if_stack.push(CurrentLabel());
    } stmt {
        function_list.back().AddStatement("BA", NewLabel());
        
        string outLayer = if_stack.top(); if_stack.pop();
        function_list.back().AddLabel(outLayer);
        if_stack.push(CurrentLabel());
    } elsepart {
        function_list.back().AddLabel(if_stack.top()); if_stack.pop();
    }
    ;

elsepart: 
    ELSE stmt
	| /* Epsilon */
	;

%%

int main(int argc, char * argv[]) {
    auto file_name = argv[1];
    lexer = LexicalAnalyzer(file_name);
    
    num_temps = 0; num_labels = 0;

    // Generate intermediate code using the above grammar
    yyparse();

    MakeAssembly();
    
    return 0;
}

void MakeAssembly() {
    // Translate each function into assembly
    for (auto &func : function_list) {
        func.Translate(true);
    }
    
}

int yylex() {

    // Get the next token from the token_list
    TokenPair next_token = lexer.NextToken();
    auto next_token_type = next_token.Type();

    // Return -1 to signify EOF
    if (next_token_type == "EOF") {
	    return -1;
    } else if (next_token_type == "NUMBER") {
	    // Set yylval to the token's contents (as an int)
	    yylval.ival = stoi(next_token.Contents());
	    // return the token type
	    return NUMBER;
    } else {
	    yylval.sval = new string(next_token.Contents());
	    // Execute an if/else series to determine what token type
	    // to return to yyparse
	    if (next_token_type == "STRING") {
	        return STRING;
	    } else if (next_token_type == "FUNCTION") {
	        return FUNCTION;
	    } else if (next_token_type == "ID") {
	        return ID;
	    } else if (next_token_type == "ADDOP") {
	        return ADDOP;
	    } else if (next_token_type == "MULOP") {
	        return MULOP;
	    } else if (next_token_type == "RELOP") {
	        return RELOP;
	    } else if (next_token_type == "ASSIGNOP") {
	        return ASSIGNOP;
	    } else if (next_token_type == "AND") {
	        return AND;
	    } else if (next_token_type == "OR") {
	        return OR;
	    } else if (next_token_type == "NOT") {
	        return NOT;
	    } else if (next_token_type == "CURLL") {
	        return CURLL;
	    } else if (next_token_type == "CURLR") {
	        return CURLR;
	    } else if (next_token_type == "PARENL") {
	        return PARENL;	
	    } else if (next_token_type == "PARENR") {
	        return PARENR;
	    } else if (next_token_type == "COMMA") {
	        return COMMA;
	    } else if (next_token_type == "SEMICOLON") {
	        return SEMICOLON;
	    } else if (next_token_type == "IF") {
	        return IF;
	    } else if (next_token_type == "ELSE") {
	        return ELSE;
	    } else if (next_token_type == "WHILE") {
	        return WHILE;
	    } else if (next_token_type == "VAR") {
	        return VAR;
	    } else if (next_token_type == "RETURN") {
	        return RETURN;
	    }
    }
    return -1;
}
