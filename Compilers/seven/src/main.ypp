%{

#include "file_handler.hpp"
#include "print.hpp"
#include "tokenizer.hpp"
#include "token_list.hpp"

#include <iostream>
#include <string>

using namespace std;

int num_temp_vars;
int num_layers;
TokenList token_list;

int yylex();
int yyerror(const char* msg) {
    cerr << "Error: " << msg << endl;
    return 1;
}

string NewTempVar() {
    return "__T" + to_string(num_temp_vars++);
}

string NewLayer() {
    return "__L" + to_string(num_layers++);
}

%}

%union {
    bool bval;
    int ival;
    string * sval;
}

%token<ival> NUMBER
%token<sval> 
    STRING ADDOP MULOP RELOP ASSIGNOP
    FUNCTION RETURN VAR ID IF
    ELSE WHILE AND COMMA CURLL
    CURLR NOT OR PARENL PARENR SEMICOLON
    ;
    
%type<ival>
    expr factor
    ;
    
%type<sval>
    fcall body
    ;

%%

pgm:
    pgmpart pgm
    | pgmpart
    ;
    
pgmpart:
    vardecl
	| function
	;
	 
vardecl:
    VAR varlist SEMICOLON
	;
	
varlist:
    ID COMMA varlist
    | ID
    ;

function:
    FUNCTION ID PARENL PARENR {
        // Create a new symbol table for the function
        num_layers = 0;
        // Print the function out
        PrintFunc(*$2);
    } body
    | FUNCTION ID PARENL fplist PARENR {
        // Create a new symbol table for the function
        num_layers = 0;
        // Print the function out
        PrintFunc(*$2);
    } body
    ;

body:
    CURLL bodylist CURLR { $$ = new string("foo"); }
    ;

fplist:	
    ID COMMA fplist
	| ID
	;

bodylist:
    vardecl bodylist
    | stmt bodylist
    | /* (Epsilon, AKA Nothing) */
    ;

stmt: 
    assign SEMICOLON
    | fcall SEMICOLON
    | while
    | if
    | body
    ;

assign:
    ID ASSIGNOP expr
    ;

expr: 
    factor
    | expr ADDOP factor
    ;

factor:
    term {
        // Look up the term's value in the symbol table and set it to factor
    }
	| factor MULOP term
	;

term: 
    ID
    | NUMBER {
        // Create a new temp variable
        // MOV the NUMBER into the temp variable
        // set term to the new temp variable
    }
    | PARENL expr PARENR
    | ADDOP term
    | fcall {
        // Create a new temp variable
        // 
    }
    ;

bexpr: 
    bfactor
    | bexpr OR bfactor
    ;

bfactor: 
    bneg
    | bfactor AND bneg
    ;

bneg: 
    bterm
	| NOT bterm
	;

bterm: 
    expr RELOP expr {
        if (*$2 == "<") {
            //PrintInstruct("LT")
        } else if (*$2 == ">") {
            
        } else if (*$2 == "==") {
            
        } else if (*$2 == "!=") {
            
        } else if (*$2 == "<=") {
            
        } else if (*$2 == ">=") {
            
        }
    }
    | PARENL bterm PARENR
    ;

fcall: 
    ID PARENL PARENR {
        // Print the CALL instruction
        PrintInstruct("CALL", *$1);
        // Store the result in a new temp variable
        //PrintInstruct("STRET")
    }
    | ID PARENL aplist PARENR {
        PrintInstruct("CALL", *$1);
        // Store the result in a new temp variable
        //PrintInstruct("STRET")
    }
    ;

aplist:
    expr COMMA aplist
	| expr 
	| STRING
	;

while:
    WHILE PARENL bexpr PARENR stmt
	;

if: 
    IF PARENL bexpr PARENR stmt elsepart
    ;

elsepart: 
    ELSE stmt
	| /* Epsilon */
	;

%%

int main(int argc, char* argv[]) {
    try {
        auto file_name = argv[1];
        if (file_name == nullptr) {
	        throw logic_error("Missing input file argument");
	    } else {
	        // Construct a wrapper around the input file
	        FileHandler input_file(file_name);

	        // Extract the contents of the input file
	        auto file_contents = input_file.ExtractSourceCode();
	        
	        // Construct the tokenizer
	        Tokenizer tokenizer(file_contents);
	        
	        // Create the list of tokens from the file's contents
	        auto tokens = tokenizer.Tokenize();
	        
	        // Copy construct the TokenList
	        token_list = TokenList(tokens);
	    }
    } catch (const logic_error &err) {
        cerr << err.what() << endl;
        return 1;
    } catch (const runtime_error &err) {
        cerr << err.what() << endl;
        return 2;
    }
    
    // Reset the counters
    num_temp_vars = 0;

    // Run the parser
    yyparse();
    
    return 0;
}

int yylex() {

    // Get the next token from the token_list
    TokenPair next_token = token_list.NextToken();
    auto next_token_type = next_token.Type();

    // Return -1 to signify EOF
    if (next_token_type == "EOF") {
	    return -1;
    } else if (next_token_type == "NUMBER") {
	    // Set yylval to the token's contents (as an int)
	    yylval.ival = stoi(next_token.Contents());
	    // return the token type
	    return NUMBER;
    } else {
	
	    yylval.sval = new string(next_token.Contents());
	    
	    // Execute an if/else series to determine what token type
	    // to return to yyparse
	    if (next_token_type == "STRING") {
	        return STRING;
	    } else if (next_token_type == "FUNCTION") {
	        return FUNCTION;
	    } else if (next_token_type == "ID") {
	        return ID;
	    } else if (next_token_type == "ADDOP") {
	        return ADDOP;
	    } else if (next_token_type == "MULOP") {
	        return MULOP;
	    } else if (next_token_type == "RELOP") {
	        return RELOP;
	    } else if (next_token_type == "ASSIGNOP") {
	        return ASSIGNOP;
	    } else if (next_token_type == "AND") {
	        return AND;
	    } else if (next_token_type == "OR") {
	        return OR;
	    } else if (next_token_type == "NOT") {
	        return NOT;
	    } else if (next_token_type == "CURLL") {
	        return CURLL;
	    } else if (next_token_type == "CURLR") {
	        return CURLR;
	    } else if (next_token_type == "PARENL") {
	        return PARENL;	
	    } else if (next_token_type == "PARENR") {
	        return PARENR;
	    } else if (next_token_type == "COMMA") {
	        return COMMA;
	    } else if (next_token_type == "SEMICOLON") {
	        return SEMICOLON;
	    } else if (next_token_type == "IF") {
	        return IF;
	    } else if (next_token_type == "ELSE") {
	        return ELSE;
	    } else if (next_token_type == "WHILE") {
	        return WHILE;
	    } else if (next_token_type == "VAR") {
	        return VAR;
	    } else if (next_token_type == "RETURN") {
	        return RETURN;
	    }
    }
    return -1;
}
