%{
#include "file_handler.hpp"
#include "print.hpp"
#include "tokenizer.hpp"
#include "token_list.hpp"

#include <iostream>
#include <iterator>
#include <map>
#include <stack>
#include <string>

using namespace std;

// Shameful global variables
int num_func_defs, num_stmts;
int num_temp_vars;

// Function declarations
int yylex();
int yyerror(const char* message) {
    std::cerr << "Error: " << message << std::endl;
    return 0;
}

string NewTempVar() {
    return "__T" + to_string(num_temp_vars++);
}
// Shameful, but works for now
TokenList token_list;

using ScopeVars = map<string, int>;
ScopeVars variables;
%}

%union {
    bool bval;
    int ival;
    string* sval;
}

// Token declarations
			
%token<ival> NUMBER
%token<sval> 
    STRING ADDOP MULOP RELOP ASSIGNOP
    FUNCTION RETURN VAR ID IF
    ELSE WHILE AND COMMA CURLL
    CURLR NOT OR PARENL PARENR SEMICOLON
    ;
    
%type<bval>
    bexpr bfactor bneg bterm
    ;
    
%type<ival>
    expr factor term
    ;

%destructor { delete $$; } 
    STRING ADDOP MULOP RELOP ASSIGNOP 
    FUNCTION RETURN VAR ID IF ELSE 
    WHILE AND COMMA CURLL CURLR 
    NOT OR PARENL PARENR SEMICOLON

%%
// Grammar definitions

pgm:
    pgmpart pgm
    | pgmpart
    ;

pgmpart: 
    vardecl
	| function
	;
	 
vardecl: 
    VAR varlist SEMICOLON
	;

varlist:
    ID COMMA {
        
    } varlist
    | ID {
        
    }
    ;

function:
    FUNCTION ID PARENL PARENR {
        // Make a new symbol table
	    PrintFunc(*$2);
    } body { 
        ++num_func_defs; 
    }
    | FUNCTION ID PARENL fplist PARENR {
        // Make a new stack of variables
        PrintFunc(*$2);
    } body { 
        ++num_func_defs; 
    }
    ;

body:
    CURLL bodylist CURLR
    ;

fplist:	
    ID COMMA fplist
	| ID
	;

bodylist:
    vardecl bodylist
    | stmt bodylist
    | /* (Epsilon, AKA Nothing) */
    ;

stmt: 
    assign SEMICOLON { ++num_stmts; }
    | fcall SEMICOLON { ++num_stmts; }
    | while { ++num_stmts; }
    | if { ++num_stmts; }
    | body
    ;

assign:	
    ID ASSIGNOP expr {
        string ID_name = *$1;
        variables[ID_name] = $3;
        string s = to_string($3) + ", " + (*$1);
        PrintInstruct("MOV", s);
    }
    ;

expr: 
    factor { $$ = $1; }
    | expr ADDOP factor {
        string instruct;
        if ((*$2)[0] == '+') {
            instruct = "ADD";
            $$ = $1 + $3;
        } else {
            instruct = "SUB";
            $$ = $1 - $3;
        }
        string args = to_string($1) + ", " + to_string($3) + ", " + 
                      NewTempVar();
        PrintInstruct(instruct, args);
    }
    ;

factor:
    term { $$ = $1; }
	| factor MULOP term {
	    if ((*$2)[0] == '*') {
	        $$ = $1 * $3;
	    } else {
	        $$ = $1 / $3;
	    }
    }
	;

term: 
    ID  //{ $$.sval = $1.sval; }
    | NUMBER {
	  // Generate a new temporary variable
	  // Create a MOV instruction
	  // Print it
	  string s = to_string($1) + ", " + NewTempVar();
	  PrintInstruct("MOV", s);
	  // add it to the current symbol table as an int
	}
    | PARENL expr PARENR
    | ADDOP term {
        if ((*$1)[0] == '-') {
            auto new_temp = NewTempVar();
            std::string s = to_string($2) + ", " + new_temp;
            PrintInstruct("NEG", s);
            $$ = -$2;
        }
    }
    | fcall {
        //$$ = $1;
    }
    ;

bexpr: 
    bfactor
    | bexpr OR bfactor
    ;

bfactor: 
    bneg
	 | bfactor AND bneg {
	    
	 }
	 ;

bneg: 
    bterm {
        
    }
	| NOT bterm {
	    
	}
	;

bterm: 
    expr RELOP expr {
        
    }
    | PARENL bterm PARENR {
        
    }
    ;

fcall: 
    ID PARENL PARENR { 
        PrintInstruct("CALL", *$1); 
        PrintInstruct("STRET", NewTempVar());
    }
    | ID PARENL aplist PARENR { PrintInstruct("CALL", *$1); }
    ;

aplist:
    expr COMMA aplist
	| expr { PrintInstruct("PARAMe", to_string($1)); }
	| STRING { PrintInstruct("PARAMs", *$1); }
	;

while:
    WHILE PARENL bexpr PARENR stmt
	;

if: 
    IF PARENL bexpr PARENR stmt elsepart
    ;

elsepart: 
    ELSE stmt
	| /* Epsilon */
	;

%%

int main(int argc, char *argv[]) {

    // Attempt to open the input file, read its contents,
    // Tokenize it, and create a TokenList from it.
    // If the file cannot be opened, then an error is thrown and the program
    // Is exited
    try {
	auto file_name = argv[1];
	// Throw an error if missing the input file arg
	if (file_name == nullptr) {
	    throw logic_error("Missing input file argument");
	} else{
	    // Construct a wrapper around the input file
	    FileHandler input_file(file_name);

	    // Extract the contents of the input file
	    auto file_contents = input_file.ExtractSourceCode();
	    
	    // Construct the tokenizer
	    Tokenizer tokenizer(file_contents);
	    
	    // Create the list of tokens from the file's contents
	    auto tokens = tokenizer.Tokenize();
	    
	    // Copy construct the TokenList
	    token_list = TokenList(tokens);
	}
    } catch(const logic_error &err) {
	// Print the error message and exit
	cerr << err.what() << endl;
	return 1;
    } catch (const runtime_error &err) {
	// Print the error message and exit
	cerr << err.what() << endl;
	return 2;
    }

    // Reset the counters
    num_func_defs = 0;
    num_stmts = 0;
    num_temp_vars = 0;

    // Run the parser
    yyparse();
    
    return 0;
}

int yylex() {

    // Get the next token from the token_list
    TokenPair next_token = token_list.NextToken();
    auto next_token_type = next_token.Type();

    // Return -1 to signify EOF
    if (next_token_type == "EOF") {
	    return -1;
    } else if (next_token_type == "NUMBER") {
	    // Set yylval to the token's contents (as an int)
	    yylval.ival = stoi(next_token.Contents());
	    // return the token type
	    return NUMBER;
    } else {

	// Shameful
	// Set yylval to the char * equivalent of the token's contents
//	if (yylval.sval != nullptr) {
//	    delete yylval.sval;
//	}
	
	yylval.sval = new string(next_token.Contents());
	

	// Execute an if/else series to determine what token type
	// to return to yyparse
	if (next_token_type == "STRING") {
	    return STRING;
	} else if (next_token_type == "FUNCTION") {
	    return FUNCTION;
	} else if (next_token_type == "ID") {
	    return ID;
	} else if (next_token_type == "ADDOP") {
	    return ADDOP;
	} else if (next_token_type == "MULOP") {
	    return MULOP;
	} else if (next_token_type == "RELOP") {
	    return RELOP;
	} else if (next_token_type == "ASSIGNOP") {
	    return ASSIGNOP;
	} else if (next_token_type == "AND") {
	    return AND;
	} else if (next_token_type == "OR") {
	    return OR;
	} else if (next_token_type == "NOT") {
	    return NOT;
	} else if (next_token_type == "CURLL") {
	    return CURLL;
	} else if (next_token_type == "CURLR") {
	    return CURLR;
	} else if (next_token_type == "PARENL") {
	    return PARENL;	
	} else if (next_token_type == "PARENR") {
	    return PARENR;
	} else if (next_token_type == "COMMA") {
	    return COMMA;
	} else if (next_token_type == "SEMICOLON") {
	    return SEMICOLON;
	} else if (next_token_type == "IF") {
	    return IF;
	} else if (next_token_type == "ELSE") {
	    return ELSE;
	} else if (next_token_type == "WHILE") {
	    return WHILE;
	} else if (next_token_type == "VAR") {
	    return VAR;
	} else if (next_token_type == "RETURN") {
	    return RETURN;
	}
    }
    return -1;
}
